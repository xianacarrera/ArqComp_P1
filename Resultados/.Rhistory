?t.test
library(TeachingDemos)
# En este caso tambiÃ©n tenemos que cargar un paquete
library(TeachingDemos)
?z.test
library(TeachingDemos)
library(TeachingDemos)
# En R existe una funciÃ³n que nos permite calcular automÃ¡ticamente la media
# con varianza conocida
# Tenemos que descargar un paquete, TeachingDemos
# install.packages("TeachingDemos")
library(TeachingDemos)
install.packages("TeachingDemos")
# En R existe una funciÃ³n que nos permite calcular automÃ¡ticamente la media
# con varianza conocida
# Tenemos que descargar un paquete, TeachingDemos
# install.packages("TeachingDemos")
library(TeachingDemos)
?z.test
?prop.test
setwd("D:/USUARIO/Desktop/Arquitectura de Computadores/P1_Repo/Resultados/1 3 7 8 16/D")
# Xiana Carrera Alonso, Ana Carsi González
# Arquitectura de Computadores - Curso 2021/2022
# Práctica 1 - Jerarquía de memoria y comportamiento de memoria cache: Estudio del
# efecto de la localidad de los accesos a memoria en las prestaciones de programas
# en microprocesadores.
#
# Este programa de R permite visualizar los resultados obtenidos en forma de 5
# gráficas, 3 en 2D y 2 en 3D.
# Leemos los datos, con una cabecera inicial, separados por un espacio
# y con un punto como marca decimal
datos <- read.table("1 3 7 8 16 O0 D.txt", header=T, sep=" ", dec=".")
attach(datos)     # Convertimos los componentes de datos en variables
head(datos)       # Lectura de una muestra de los datos
summary(datos)    # Resumen estadístico de los datos
str(datos)        # Estructura (tipo de dato) de la muestra
#**************************************************************************
# Gráfica 1 (2D): Número de ciclos (eje Y) en función de L (eje X) para
# cada D (colores).
#**************************************************************************
lista_D <- unique(D)  # Distintos valores que toma D
lista_D
# Añadimos espacio extra de márgenes
# Con xpd, controlamos que el plot esté anclado a la región de dibujo
par(mar=c(5, 4, 4, 8), xpd=TRUE)
# Vamos a representar la relación entre L y CK, utilizando una línea distinta
# para cada valor de D (5 líneas en total)
# No indicamos eje X para configurarlo a continuación manualmente
# En este plot representamos en primer lugar el valor más bajo de D
# El tipo de representación es "overplotted" (puntos y líneas)
plot(L[D==min(D)], CK[D==min(D)], type="o", xaxt="n",
ylim=c(floor(min(CK)), ceiling(max(CK))),
col=1, pch=19,
xlab = "",
ylab = "Número de ciclos de reloj por acceso a memoria")
# Recorremos todos los elementos de lista_D menos el primero [-1]
for (i in lista_D[-1]){
# Con which obtenemos el índice del elemento de la lista que es igual a i
lines(L[D==i], CK[D==i], type="o", col=which(i==lista_D), pch=19)
}
par(xpd=F)
# Quitamos los márgenes para incluir una rejilla únicamente
# dentro del área gráfica
grid(nx = NULL, ny = NULL, lty = 2, col = "lightgray", lwd = 1)
# Volvemos a activar los márgenes
par(xpd=T)
# Añadimos una leyenda de colores para D
legend("right", legend=levels(factor(D)), lty=1, lwd=3, col = 1:5,
title = "D", inset=c(-0.2, 0))
# Introducimos un título y un subtítulo
mtext(side = 3, line = 2, cex=1,
"Coste en ciclos de cada acceso a memoria por número de líneas caché diferentes referenciadas")
mtext(side = 3, line = 1, cex=0.8,
"Influencia de L, con datos agrupados por D (número de posiciones entre los elementos a sumar)")
# Especificamos el texto del eje X con mtext para controlar su posición
# (side = 1 -> debajo del gráfico)
mtext(side = 1, line = 3.8, cex = 1,
"L (número de líneas caché diferentes del vector A[] referenciadas)")
axis(1, at=L, las=3, lwd=1)
#**************************************************************************
# Gráfica 2 (2D): Número de ciclos (eje Y) en función de D (eje X) para
# cada L (colores).
#**************************************************************************
lista_L <- unique(L)    # Distintos valores que toma L
lista_L
# Añadimos espacio extra de márgenes
# Con xpd, controlamos que el plot esté anclado a la región de dibujo
par(mar=c(5, 4, 4, 8), xpd=TRUE)
# De forma análoga a la gráfica 1, imprimimos una línea con puntos para
# cada valor de L, comenzando por aquella de menor valor
plot(D[L==min(L)], CK[L==min(L)], type="o", xaxt="n",
col=1, pch=19,
ylim=c(floor(min(CK)), ceiling(max(CK))),
xlab = "",
ylab = "Número de ciclos de reloj por acceso a memoria")
par(xpd=F)
# Quitamos los márgenes para incluir una rejilla únicamente
# dentro del área gráfica
grid(nx = NULL, ny = NULL, lty = 2, col = "lightgray", lwd = 1)
# Volvemos a activar los márgenes
par(xpd=T)
# Añadimos un título y un subtítulo
mtext(side = 3, line = 2, cex=1,
"Coste en ciclos de cada acceso a memoria según el espacio entre los sumandos de A[]")
mtext(side = 3, line = 1, cex=0.8,
"Influencia de D, con datos agrupados por L (número de líneas caché diferentes referenciadasr)")
# Recorremos todos los elementos de lista_L menos el primero [-1]
for (i in lista_L[-1]){
# Con which obtenemos el índice del elemento de la lista que es igual a i
lines(D[L==i], CK[L==i], type="o", col=which(i==lista_L), pch=19)
}
# Añadimos una leyenda en el margen derecho
legend("right", legend=levels(factor(L)), lty=1, lwd=3, col = 1:7,
title = "L", inset=c(-0.25, 0))
# Configuramos el eje X y cambiamos las etiquetas para que coincidan con los
# valores de D
mtext(side = 1, line = 3.8, cex = 1,
"D (número de posiciones entre los elementos a sumar de A[])")
axis(1, at=D, las=1, lwd=1)
setwd("D:/USUARIO/Desktop/Arquitectura de Computadores/P1_Repo/Resultados")
# Xiana Carrera Alonso, Ana Carsi González
# Arquitectura de Computadores - Curso 2021/2022
# Práctica 1 - Jerarquía de memoria y comportamiento de memoria cache: Estudio del
# efecto de la localidad de los accesos a memoria en las prestaciones de programas
# en microprocesadores.
#
# Este programa de R permite visualizar los resultados obtenidos en forma de 5
# gráficas, 3 en 2D y 2 en 3D.
# Leemos los datos, con una cabecera inicial, separados por un espacio
# y con un punto como marca decimal
datos <- read.table("1 6 8 15 71 O0 D.txt", header=T, sep=" ", dec=".")
attach(datos)     # Convertimos los componentes de datos en variables
head(datos)       # Lectura de una muestra de los datos
summary(datos)    # Resumen estadístico de los datos
str(datos)        # Estructura (tipo de dato) de la muestra
#**************************************************************************
# Gráfica 1 (2D): Número de ciclos (eje Y) en función de L (eje X) para
# cada D (colores).
#**************************************************************************
lista_D <- unique(D)  # Distintos valores que toma D
lista_D
# Añadimos espacio extra de márgenes
# Con xpd, controlamos que el plot esté anclado a la región de dibujo
par(mar=c(5, 4, 4, 8), xpd=TRUE)
# Vamos a representar la relación entre L y CK, utilizando una línea distinta
# para cada valor de D (5 líneas en total)
# No indicamos eje X para configurarlo a continuación manualmente
# En este plot representamos en primer lugar el valor más bajo de D
# El tipo de representación es "overplotted" (puntos y líneas)
plot(L[D==min(D)], CK[D==min(D)], type="o", xaxt="n",
ylim=c(floor(min(CK)), ceiling(max(CK))),
col=1, pch=19,
xlab = "",
ylab = "Número de ciclos de reloj por acceso a memoria")
# Recorremos todos los elementos de lista_D menos el primero [-1]
for (i in lista_D[-1]){
# Con which obtenemos el índice del elemento de la lista que es igual a i
lines(L[D==i], CK[D==i], type="o", col=which(i==lista_D), pch=19)
}
par(xpd=F)
# Quitamos los márgenes para incluir una rejilla únicamente
# dentro del área gráfica
grid(nx = NULL, ny = NULL, lty = 2, col = "lightgray", lwd = 1)
# Volvemos a activar los márgenes
par(xpd=T)
# Añadimos una leyenda de colores para D
legend("right", legend=levels(factor(D)), lty=1, lwd=3, col = 1:5,
title = "D", inset=c(-0.2, 0))
# Introducimos un título y un subtítulo
mtext(side = 3, line = 2, cex=1,
"Coste en ciclos de cada acceso a memoria por número de líneas caché diferentes referenciadas")
mtext(side = 3, line = 1, cex=0.8,
"Influencia de L, con datos agrupados por D (número de posiciones entre los elementos a sumar)")
# Especificamos el texto del eje X con mtext para controlar su posición
# (side = 1 -> debajo del gráfico)
mtext(side = 1, line = 3.8, cex = 1,
"L (número de líneas caché diferentes del vector A[] referenciadas)")
axis(1, at=L, las=3, lwd=1)
#**************************************************************************
# Gráfica 2 (2D): Número de ciclos (eje Y) en función de D (eje X) para
# cada L (colores).
#**************************************************************************
lista_L <- unique(L)    # Distintos valores que toma L
lista_L
# Añadimos espacio extra de márgenes
# Con xpd, controlamos que el plot esté anclado a la región de dibujo
par(mar=c(5, 4, 4, 8), xpd=TRUE)
# De forma análoga a la gráfica 1, imprimimos una línea con puntos para
# cada valor de L, comenzando por aquella de menor valor
plot(D[L==min(L)], CK[L==min(L)], type="o", xaxt="n",
col=1, pch=19,
ylim=c(floor(min(CK)), ceiling(max(CK))),
xlab = "",
ylab = "Número de ciclos de reloj por acceso a memoria")
par(xpd=F)
# Quitamos los márgenes para incluir una rejilla únicamente
# dentro del área gráfica
grid(nx = NULL, ny = NULL, lty = 2, col = "lightgray", lwd = 1)
# Volvemos a activar los márgenes
par(xpd=T)
# Añadimos un título y un subtítulo
mtext(side = 3, line = 2, cex=1,
"Coste en ciclos de cada acceso a memoria según el espacio entre los sumandos de A[]")
mtext(side = 3, line = 1, cex=0.8,
"Influencia de D, con datos agrupados por L (número de líneas caché diferentes referenciadasr)")
# Recorremos todos los elementos de lista_L menos el primero [-1]
for (i in lista_L[-1]){
# Con which obtenemos el índice del elemento de la lista que es igual a i
lines(D[L==i], CK[L==i], type="o", col=which(i==lista_L), pch=19)
}
# Añadimos una leyenda en el margen derecho
legend("right", legend=levels(factor(L)), lty=1, lwd=3, col = 1:7,
title = "L", inset=c(-0.25, 0))
# Configuramos el eje X y cambiamos las etiquetas para que coincidan con los
# valores de D
mtext(side = 1, line = 3.8, cex = 1,
"D (número de posiciones entre los elementos a sumar de A[])")
axis(1, at=D, las=1, lwd=1)
